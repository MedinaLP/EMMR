# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17LWQbC_wi45aZ8R5ZJgYozzVig0yWGiO

# DATA PROCESSING AND CLEANING
"""

# ðŸ“š Data-Driven Global Prediction of Blood Type Probabilities for Donors and Patients
# Name: Espinosa, Catherine Dane | Medina, Lhiela Ericka | Munda, Reigne Isiah | Rangas, Chynna Mae
# Date: June 2, 2025

# ===============================================================
# 2. Data Acquisition and Preprocessing
# ===============================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import MinMaxScaler

#from google.colab import files
#uploaded = files.upload()

df = pd.read_csv('bloodtypes.csv')
df.head()

print("--------------------------------------------------")
print("Information from Global Bloodtype Dataset:")
print("--------------------------------------------------\n")
df.info()

print("\n--------------------------------------------------")
print("Statistical Summary of Global Bloodtype Dataset:")
print("--------------------------------------------------\n")
print(df.describe(include='all'))

print("\n--------------------------------------------------")
print("Missing Values from Global Bloodtype Dataset:")
print("--------------------------------------------------\n")
print(df.isnull().sum())

# Data Cleaning (Handle Missing Values, Duplicates, Inconsistencies)

df.fillna(0, inplace=True)
print("Missing Values Filled...")

print("Number of duplicate rows:", df.duplicated().sum())
df.drop_duplicates(inplace=True)

df['Country'] = df['Country'].str.strip()

# Data Transformation (Normalization, Encoding and Feature Engineering)
le = LabelEncoder()
df['Country_Num'] = le.fit_transform(df['Country'])
print("Countries are now assigned integer values...")

# Feature Engineering
df['Total_Rh_Pos'] = df[['O+', 'A+', 'B+', 'AB+']].sum(axis=1)
df['Total_Rh_Neg'] = df[['O-', 'A-', 'B-', 'AB-']].sum(axis=1)
bloodtype_columns = ['O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-']
df['Rarest_Blood_Type'] = df[bloodtype_columns].idxmin(axis=1)
df['Most_Common_Blood_Type'] = df[bloodtype_columns].idxmax(axis=1)

print("\n--------------------------------------------------")
print("Preview of Data before Scaling")
print("--------------------------------------------------")
print(df.head())
df.to_csv('cleaned_data.csv', index=False)

# Normalization
scaler = MinMaxScaler()
cols_to_normalize = ['Population', 'O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-', 'Total_Rh_Pos', 'Total_Rh_Neg']
df[cols_to_normalize] = scaler.fit_transform(df[cols_to_normalize])

print("\n--------------------------------------------------")
print("Preview of Transformed Data")
print("--------------------------------------------------")
print(df.head())

"""# DATA ANALYSIS AND PLOTTING"""

# ===============================================================
# 3. Exploratory Data Analysis
# ===============================================================

import plotly.express as px
import plotly.graph_objects as go

# Histogram of Total Rh+ and Total Rh-
fig1 = px.histogram(df, x='Total_Rh_Pos', nbins=20, title='Distribution of Total Rh+ Blood Type',
                    labels={'Total_Rh_Pos': 'Total Rh+ (%)'}, template='plotly')
fig1.update_traces(marker_color='salmon')
fig1.show()

fig2 = px.histogram(df, x='Total_Rh_Neg', nbins=20, title='Distribution of Total Rh- Blood Type',
                    labels={'Total_Rh_Neg': 'Total Rh- (%)'}, template='plotly')
fig2.update_traces(marker_color='skyblue')
fig2.show()

# Scatter Plot of Population vs Total Rh+ and Rh-
fig3 = px.scatter(df, x='Population', y='Total_Rh_Pos',
                  title='Population vs Total Rh+ Blood Type',
                  labels={'Total_Rh_Pos': 'Total Rh+ (%)', 'Population': 'Population'},
                  hover_name='Country')
fig3.update_traces(marker=dict(size=10, color='red'))
fig3.show()

fig4 = px.scatter(df, x='Population', y='Total_Rh_Neg',
                  title='Population vs Total Rh- Blood Type',
                  labels={'Total_Rh_Neg': 'Total Rh- (%)', 'Population': 'Population'},
                  hover_name='Country')
fig4.update_traces(marker=dict(size=10, color='blue'))
fig4.show()

# Bar Chart for Global average of Rh+ and Rh-
avg_rh = pd.DataFrame({
    'Rh Type': ['Rh+', 'Rh-'],
    'Average %': [df['Total_Rh_Pos'].mean(), df['Total_Rh_Neg'].mean()]
})
fig5 = px.bar(avg_rh, x='Rh Type', y='Average %', title='Average Rh+ vs Rh- Across All Countries',
              text_auto=True, color='Rh Type', template='plotly')
fig5.show()

# Correlation Heatmap  of blood type features and population
plt.figure(figsize=(12, 8))
correlation = df[['Population', 'O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-', 'Total_Rh_Pos', 'Total_Rh_Neg']].corr()
sns.heatmap(correlation, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Correlation Heatmap of Blood Type Features')
plt.show()

"""# MODEL BUILDING AND EVALUATION"""

# ===============================================================
# 4. Model Building and Evaluation
# ===============================================================

import xgboost as xgb
from sklearn.model_selection import train_test_split, cross_val_score, StratifiedKFold
from sklearn.metrics import classification_report, confusion_matrix
from xgboost import XGBClassifier
import plotly.figure_factory as ff
import matplotlib.pyplot as plt

# 1: Define Features of Model and what feature to target (Most Common/ Least Common Blood Type)
features = ['O+', 'A+', 'B+', 'AB+', 'O-', 'A-', 'B-', 'AB-']
target = 'Most_Common_Blood_Type'

X = df[features]
y = df[target]

le = LabelEncoder()
y_encoded = le.fit_transform(y)

# 2: Training and Testing Split
X_train, X_test, y_train_encoded, y_test_encoded = train_test_split(X, y_encoded, test_size=0.2, random_state=42, stratify=y_encoded)

# 3: Defining the XGBoost Model
xgb_model = XGBClassifier(
    objective='multi:softmax',
    num_class=len(le.classes_),
    n_estimators=100,
    learning_rate=0.1,
    max_depth=6,
    random_state=42
)

# 4: Cross Validation of Data
cv = StratifiedKFold(n_splits=3, shuffle=True, random_state=42)
cv_scores = cross_val_score(xgb_model, X_train, y_train_encoded, cv=cv, scoring='accuracy')

# 5: Training and Prediction
xgb_model.fit(X_train, y_train_encoded)
y_pred = xgb_model.predict(X_test)

# 6: Performance Summaries
print(f"Cross-validation Accuracy Scores: {cv_scores}")
print(f"Average Cross Validation Accuracy: {cv_scores.mean():.4f}")
print("\nClassification Report with other metrics:")
print(classification_report(y_test_encoded, y_pred))

cm = confusion_matrix(y_test_encoded, y_pred, labels=xgb_model.classes_)

fig = ff.create_annotated_heatmap(
    z=cm,
    x=xgb_model.classes_.tolist(),
    y=xgb_model.classes_.tolist(),
    colorscale='Blues'
)
fig.update_layout(
    title='Confusion Matrix - XGBoost Model',
    xaxis_title='Predicted Label',
    yaxis_title='True Label'
)
fig.show()

xgb.plot_importance(xgb_model, importance_type='weight', title='Feature Importance')
plt.tight_layout()
plt.show()

"""# DEPLOYMENT OF PROTOTYPE DASHBOARD"""

